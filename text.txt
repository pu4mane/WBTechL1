Устные вопросы

1.Какой самый эффективный способ конкатенации строк?

strings.Builder гибкий и производительный способ конкатенации строк, позволяет последовательно добавлять строки в буфер избегая копирования и затем получить готовую строку. Особенно эффективен при многократной конкантенации строки в цикле.


2.Что такое интерфейсы, как они применяются в Go?

Интерфейсы в Go - это способ определения набора методов, которые должны быть реализованы в типе данных. Они позволяют абстрагироваться от конкретных типов и работать с объектами, которые реализуют определенные методы.

package main

import (
	"fmt"
)

type Shape interface {
	Area() float64
}

type Rectangle struct {
	Width  float64
	Height float64
}

type Circle struct {
	Radius float64
}

func (r Rectangle) Area() float64 {
	return r.Width * r.Height
}

func (c Circle) Area() float64 {
	return 3.14 * c.Radius * c.Radius
}

func main() {
	rect := Rectangle{Width: 5, Height: 3}
	circ := Circle{Radius: 2}

	shapes := []Shape{rect, circ}

	for _, shape := range shapes {
		fmt.Println("Area:", shape.Area())
	}
}


3.Чем отличаются RWMutex от Mutex?

Mutex(sync.Mutex) обеспечивает эксклюзивную блокировку, что означает, что только одна горутина может захватить блокировку в определенный момент времени. Когда горутина захватывает Mutex, она блокирует доступ к общим данным до тех пор, пока не освободит блокировку. Это гарантирует, что только одна горутина может выполнять операции с общими данными в данный момент времени.

RWMutex(sync.RWMutex) предоставляет блокировку чтения/записи. Он позволяет нескольким горутинам одновременно получать доступ к общим данным для чтения, но только одной горутине разрешено получать доступ для записи. Это полезно, когда много операций чтения и меньшее количество операций записи. Блокировка чтения позволяет горутинам параллельно читать общие данные, что может повысить производительность в некоторых сценариях.


4.Чем отличаются буферизированные и не буферизированные каналы?

Буферизированный канал имеет фиксированную емкость, которая позволяет хранить несколько значений до того, как они будут прочитаны. Когда горутина отправляет значение в буферизированный канал, она может продолжить выполнение, даже если другая горутина еще не прочитала значение из канала. Если буферизированный канал заполнен, отправляющая горутина будет заблокирована до тех пор, пока другая горутина не прочитает значение из канала и освободит место в буфере.

Не буферизированный канал не имеет внутреннего буфера и требует синхронной передачи данных между горутинами. Когда горутина отправляет значение в не буферизированный канал, она будет заблокирована до тех пор, пока другая горутина не прочитает значение из канала. Аналогично, когда горутина читает значение из не буферизированного канала, она будет заблокирована до тех пор, пока другая горутина не отправит значение в канал.


5.Какой размер у структуры struct{}{}?

Размер структуры struct{}{} в Go 0 байт. Cтруктура не содержит никаких полей или данных.


6.Есть ли в Go перегрузка методов или операторов?

В Go нет поддержки перегрузки методов или операторов. В Go имена методов должны быть уникальными в пределах типа. Это означает, что нельзя создать несколько методов с одинаковыми именами, но разными параметрами или типами возвращаемых значений.

Go нет возможности перегрузки операторов.

Вместо перегрузки методов и операторов, Go обычно использует именованные функции с различными именами для различных вариантов поведения или операций над данными.


7.В какой последовательности будут выведены элементы map[int]int?

Пример:
m[0]=1
m[1]=124
m[2]=281

Элементы в map[int]int в Go не имеют определенной последовательности. Порядок, в котором элементы будут выведены, не определен и может меняться при каждом запуске программы или при изменении состояния карты.


8.В чем разница make и new?

make используется для создания сложных типов данных, таких как slice, map и channel. Он инициализирует и возвращает указатель на созданный объект. Например, make([]int, 5) создаст срез []int с длиной 5 и емкостью 5.

new используется для выделения памяти для типа данных и возвращает указатель на выделенную память. Однако, new не инициализирует значения полей структуры или элементов массива, вместо этого он устанавливает все биты памяти в нули. Например, new(int) выделит память для типа int и вернет указатель на эту память.


9.Сколько существует способов задать переменную типа slice или map?

Использование литералов:
Для slice: s := []int{1, 2, 3}
Для map: m := map[string]int{"one": 1, "two": 2}
Использование функции make:
Для slice: s := make([]int, 5, 10)
Для map: m := make(map[string]int)
Использование оператора new в сочетании с приведением типа:
Для slice: s := *new([]int)
Для map: m := *new(map[string]int)
Использование переменной с предварительным объявлением:
Для slice: var s []int
Для map: var m map[string]int

10.Что выведет данная программа и почему?


func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}

1
1

Причина такого вывода заключается в том, что в функции update мы изменяем значение указателя p, но это изменение не отражается в переменной p в функции main. В функции update мы создаем новую переменную b со значением 2 и присваиваем указателю p адрес этой переменной. После выхода из функции update, указатель p в функции main остается указывать на переменную a, а не на новую переменную b. Поэтому, когда мы выводим значение *p в функции main, оно остается равным 1.

Изменение значения указателя p в функции update не влияет на значение переменной a, на которую он указывает.

11.Что выведет данная программа и почему?


func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}

Будет выведено 5 значений от 0 до 4 в произвольном порядке, после чего произойдет deadlock. Сообщение "exit" не будет выведено. Это из-за того, что в горутину передается копия объекта sync.WaitGroup, а не ссылка на него. Поэтому вызов wg.Done() не уменьшает счетчик ожидания, и программа виснет в ожидании завершения всех горутин.

12.Что выведет данная программа и почему?


func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}

0

При объявлении переменной n внутри блока if, используя оператор :=, создается новая переменная n, которая имеет область видимости только внутри этого блока. Поэтому, операция n++ увеличивает значение этой новой переменной n, но не влияет на значение переменной n вне блока if.

Когда мы выводим значение переменной n с помощью fmt.Println(n) вне блока if, оно остается равным 0.


13.Что выведет данная программа и почему?


func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}

[100, 2, 3, 4, 5]

В функции someAction, мы изменяем значение первого элемента среза v на 100 с помощью индексирования v[0] = 100. Это изменение отражается на оригинальном срезе a, так как срезы в Go являются ссылочными типами данных.

Когда мы вызываем функцию append и добавляем элемент b в срез v, это создает новый срез, который не связан с оригинальным срезом a. Поэтому, изменения, внесенные в v, не отражаются на a.


14.Что выведет данная программа и почему?


func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}

[b b a] [a a]

При вызове анонимной функции создается копия внешнего слайса. При append создается новый слайс для переменной в пределе внутренней функции, который не влияет на внешний слайс. При этом, слайс начинает указывать на другой массив, состоящий из 3 элементов и имеющий ёмкость 4. Поэтому после изменения значений внешний слайс не изменяется.
